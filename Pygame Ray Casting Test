import pygame as pg

from os import sys

from random import randint

# Settings
WIDTH, HEIGHT = 1280, 720
FPS = 60
COLORKEY = (0, 0, 0)

# Ray settings
RAYS = 180
TOT_ANGLE = 360
DRAW_ARC = False
LENGTH = 100

# Draw a reflected vector from every ray
REFLECT = False

#Grid settings
W = 13
H = 8
TILESIZE = 100
# 0 means every tile is a wall
DENSITY = 10

class Game:
    def __init__(self):
        pg.init()
        self.screen = pg.display.set_mode((WIDTH, HEIGHT))
        self.clock = pg.time.Clock()
        pg.key.set_repeat(500, 100)

    def new(self):
        self.init()

    def run(self):
        """Runs pygame."""
        while True:
            self.dt = self.clock.tick(FPS) / 1000
            self.events()
            self.update()
            self.draw()

    def events(self):
        """Catch all events here."""
        for event in pg.event.get():
            if event.type == pg.QUIT:
                pg.quit()
                sys.exit()
            if event.type == pg.KEYDOWN:
                if event.key == pg.K_ESCAPE:
                    pg.quit()
                    sys.exit()

    def init(self):
        self.RC = RayCast(self.screen)
        self.arc = self.RC._init_arc(RAYS, pg.mouse.get_pos(), TOT_ANGLE)
        self.grid = Grid(self.screen, W, H)

    def update(self):
        self.mouse_pos = pg.mouse.get_pos()

    def draw(self):
        pg.display.set_caption("{:.2f}".format(self.clock.get_fps()))
        # -----------------
        self.RC.surface.fill((0, 0, 0))
        if DRAW_ARC:
            self.RC.draw_arc(self.arc, self.mouse_pos)
        self.grid._draw_grid(self.RC.draw_arc_grid, self.arc, self.mouse_pos)
        # -----------------
        pg.display.flip()

class RayCast:
    # All coordinates exist in the regular cartesian system, once it is drawn it is
    # shifted to a specified center position. So the origin (0, 0) is the center of the
    # screen when drawn. Pygame's (0, 0) is the top left corner of the screen.
    def __init__(self, surface):
        self.surface = surface
        # Position the origin of the cartesian system is shifted to
        self.center = self.surface.get_rect().center
        self.color = COLORKEY
        self.surface.set_colorkey(self.color)

    # ---------------------------------------------------------
    def _init_arc(self, num, pos, total_angle=360):
        '''Compiles a list of radially oriented vectors pointing away from the defined position.'''
        obj_list = []
        vector = pg.math.Vector2(0, 1)
        for i in range(num):
            angle = ((i/num)*total_angle)
            new_vector =  vector.rotate(angle)
            new_vector.normalize()
            obj_list.append(new_vector)
        return obj_list
    
    def draw_arc(self, obj_list, pos):
        for ray in obj_list:
            self.draw(pos, ray*LENGTH, (255, 255, 0))


    # ------------------------------------------------------------
    def draw_arc_grid(self, rays, pos, wall):
        '''Biggest bug was removing from an iterated list during iteration, which let rays 
        pass through walls. Don't remove during iteration!!!!'''
        self.hit = False
        sorted_wall_list = self._compare_lengths(wall, pos, 0, 4)
        walls_hit = []
        for wall_pos, wall_v in sorted_wall_list:
            hit, free_rays = self.iterate_through_rays(wall_pos, wall_v*2, pos, rays)[:]
            if hit:
                rays = free_rays
                self.hit = True
                walls_hit.append([wall_pos, wall_v])
        if self.hit:
            rays = free_rays
            return rays, walls_hit

    def iterate_through_rays(self, vector_pos, vector, ray_pos, ray_list):
        '''Iterate through a given list and return a new list with only rays that have not hit something.'''
        # Any ray that doesn't hit anything will be called a 'free' ray.
        free_rays = ray_list.copy()
        hit = False
        for ray in ray_list:
            result = self.cast(vector_pos, vector, ray_pos, ray)
            if result:
                int_vector = result
                if REFLECT:
                    self.draw(int_vector, ray.reflect(vector)*-100, (175, 175, 175))
                pg.draw.line(self.surface,(255, 255, 255), ray_pos, int_vector)
                free_rays.remove(ray)
                hit = True
                continue
            else:
                continue
        return hit, free_rays
    
    def cast(self, pos1, v1, pos2, v2):
        '''This is the basis of the ray cast program.'''
        # https://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect/565282#565282
        # [q, q+s], [p, p+r] = [pos1, pos1 + v1], [pos2, pos2 + v2]
        # [q, us], [p, tr], such that q, s, p, and r are vectors
        # u is a scalar for s, and t is a scalar for r
        # let t be 'infinite' t>=0, and U = {u| u>=0, u<=1.0}, therefore r is the light ray
        # we only care about U, since it is the total length of the wall
        # intersection point = (p+tr = q+us)
        s, r = v1, v2
        if r.cross(s):
            # Python evaluates 0 as False, if the cross product is 0, then the lines exist
            # in the same span. They can be parallel, colinear, etc. Which we don't care about
            q, p = pg.math.Vector2(pos1), pg.math.Vector2(pos2)
            t = (q-p).cross(s)/(r.cross(s))
            u = (p-q).cross(r)/(s.cross(r))
            if t>=0 and u>=0 and u<=1:
                # intersected_point = (p+t*r, q+u*s), use q+u*s because it is simpler
                int_vector = (q+u*s)
                # Round, because pygame doesn't like floats
                x, y = int(int_vector[0]), int(int_vector[1])
                return int_vector
        else:
            return False

    # UTILITIES ----------------------------------------------    
    
    def _compare_lengths(self, wall, pos, start, stop):
        '''Get a list of points and return points that are closest to the input pos.'''
        new_set = []
        for wall_set in wall['sets']:
            for wall_v in wall_set['vectors']:
                new_set.append([wall_set['pos'], wall_v/2])
        new_set.sort(key=lambda x: self._get_length_from(x[0], x[1], pos))
        return new_set[start : stop]
    
    def _sort_list(self, list_, target_pos):
        '''Sorts list in ascending order based on specified function return.'''
        list_.sort(key=lambda child: self._get_length(child['pos'], target_pos))
        return list_
    
    def _get_length(self, pos, target_pos):
        '''Returns the length between two points.'''
        return pg.math.Vector2(tuple(int(a-b) for a, b in zip(pos, target_pos))).length()
    
    def _get_length_from(self, v_pos, vector, pos):
        '''Returns the length between two points.'''
        inted_vector_coordinate = self._shift_to(v_pos, vector)
        return pg.math.Vector2(tuple(int(a-b) for a, b in zip(inted_vector_coordinate, pos))).length()/2

    # ------------------------------------------------------------
    
    def draw(self, pos, vector, color=(10, 10, 10), width=1):
        ''' Draws vector to the appropriate shifted position.'''
        pg.draw.line(self.surface, color, pos, self._shift_to(pos, vector), width)
    
    def _shift_to(self, position, item):
        ''' Shifts the item to the specified position and returns the shifted coords as
        a tuple.'''
        return tuple(int(a+b) for a, b in zip(position, item))

class Grid:
    def __init__(self, surface, width, height):
        self.surface = surface
        self.grid_width = width
        self.grid_height = height
        self._init_grid()
        self._init_wall_list()

    def _init_grid(self):
        '''Uses list comprehension to build a data set for all tiles in the grid.'''
        self.array = [
            [
            {'type': randint(0, DENSITY),
            'wall': {'rect': pg.Rect((x*TILESIZE, y*TILESIZE), (TILESIZE, TILESIZE)),
                    'draw': [],
                    'sets': [{'vectors': [pg.math.Vector2(TILESIZE, 0), pg.math.Vector2(0, TILESIZE)],
                        'pos': (x*TILESIZE, y*TILESIZE)
                            }, 
                            {'vectors': [pg.math.Vector2(-TILESIZE, 0), pg.math.Vector2(0, -TILESIZE)],
                        'pos': ((x+1)*TILESIZE, (y+1)*TILESIZE)
                            }
                            ]
                    
                    }
            }
            for x in range(self.grid_width)] 
            for y in range(self.grid_height)
        ]
    
    def _init_wall_list(self):
        '''Goes through array and compiles a list only of walls which we define as being 0.'''
        self.wall_list = []
        for x, row in enumerate(self.array):
            for y, data in enumerate(row):
                if data['type'] is 0:
                    self.wall_list.append(data)
    
    # DRAW --------------------------------------------------------
    
    def _draw_grid(self, func, obj_list, pos):
        for x, row in enumerate(self.array):
            for y, data in enumerate(row):
                if data['type'] is 0:
                    pg.draw.rect(self.surface, (55, 55, 55), data['wall']['rect'])
        self.ray_cast_grid(func, obj_list, pos)
    
    def ray_cast_grid(self, func, rays, pos):
        sorted_walls = self._sort_list(self.wall_list, pos)
        for wall in sorted_walls:
            result = func(rays, pos, wall['wall'])
            if result:
                free_rays, lit_walls = result[:]
                # Update old ray list with new rays list. 
                # Don't remove from an iterated list during iteration!
                rays = free_rays
                for lit_wall in lit_walls:
                    self.draw(lit_wall[0], lit_wall[1]*2, (255, 255, 255), int(TILESIZE/10))
            elif len(rays) is 0:
                # Break out of the function if there are no more free rays.
                return            
    
    # UTILITIES ----------------------------------------------
    
    def _sort_list(self, list_, target_pos):
        '''Sorts list in ascending order based on specified function return.'''
        list_.sort(key=lambda tile: self._get_length(tile['wall'].get('rect').center, target_pos))
        return list_
    
    
    def _get_length(self, pos, target_pos):
        '''Returns the length between two points.'''
        return pg.math.Vector2(tuple(int(a-b) for a, b in zip(pos, target_pos))).length()
    
    def draw(self, pos, vector, color=(10, 10, 10), width=1):
        ''' Draws vector to the appropriate shifted position.'''
        pg.draw.line(self.surface, color, pos, self._shift_to(pos, vector), width)
    
    def _shift_to(self, position, item):
        ''' Shifts the item to the specified position and returns the shifted coords as
        a tuple.'''
        return tuple(int(a+b) for a, b in zip(position, item))

# Create game object.
g = Game()
g.new()
g.run()
